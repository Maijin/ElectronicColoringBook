{"name":"ElectronicColoringBook","tagline":"Colorize data file according to repetitive chunks, typical in ECB encrypted","body":"## Welcome to the Electronic Coloring Book project page.\r\nThe name is obviously a wordplay with [Electronic Codebook](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29), the simplest but also the most insecure chaining mode of operations to be used with a block cipher.\r\n\r\nFrom Wikipedia:\r\n> The disadvantage of this method is that identical plaintext blocks are encrypted into identical ciphertext blocks; thus, it does not hide data patterns well. In some senses, it doesn't provide serious message confidentiality, and it is not recommended for use in cryptographic protocols at all.\r\n> A striking example of the degree to which ECB can leave plaintext data patterns in the ciphertext can be seen when ECB mode is used to encrypt a bitmap image which uses large areas of uniform color. While the color of each individual pixel is encrypted, the overall image may still be discerned as the pattern of identically colored pixels in the original remains in the encrypted version.\r\n\r\nThis is typically illustrated with our favorite mascot:\r\n\r\n![ecb tux](./images/Tux_ecb.jpg)\r\n\r\nYes we can see it despite it's encrypted, but it's neither that obvious nor visually satisfying, for several reasons we'll explain. We can do better! And that's the goal of this little project.\r\n\r\n***\r\n\r\n## Why ECB forensics isn't that easy?\r\n\r\nThose ECB exemplary images are made artificially: the author knows the original file format (width, height, pixel encoding) and typically overwrites the encrypted header with the original one.\r\n\r\nBut when a file is encrypted and you don't know anything about it, it's not that simple.\r\n<br>One example is the 300 points challenge of the _2014 Nuit du Hack CTF Quals_ called _The Another One_. All you get is an encrypted BMP (as you can guess from the file extension). \r\n\r\nIt appears quickly that there are recurring encrypted blocks but practical problems are to recover the unknown parameters:\r\n* width and height of the image\r\n* pixel encoding. Here it's a BMP but BMP can [encode each pixel](https://en.wikipedia.org/wiki/BMP_file_format#Pixel_format) in 1 bit, 2 bits, 4 bits, 8 bits, 16 bits, 24 bits or 32 bits so that doesn't really help.\r\n* layout. Here it's a BMP so starting from bottom left to top right, line by line.\r\n\r\nPixel encoding, width and height link back to the total encrypted file size:\r\n\r\n_header + width * height * bytes_per_pixel + padding = filesize_\r\n\r\nI [solved manually](http://wiki.yobi.be/wiki/NDH_Writeups#Another_One) that challenge during the CTF but it's the trigger that pushed me to write this tool, to automate that painful process, and get nicer results!\r\n\r\n***\r\n\r\nHere is another example we'll walk through. For the record the binary blob was created from some ppm (as we need a non-compressed bitmap to start with) as:\r\n\r\n`openssl enc -e -aes-128-ecb -in test.ppm -out test.bin -k toto -nosalt`\r\n\r\ntest.bin is available [here](./images/test.bin)\r\n\r\nAt first we'll use a square ratio and color each byte.\r\n\r\n<img src=\"./images/test.bin.1.png\" alt=\"test.bin.1\" style=\"width: 300px;\"/>\r\n\r\nNothing really recognizable, isn't it?\r\n\r\nFor the record, this image was produced with our tool, asking for a raw rendering and square ratio:\r\n\r\n`ElectronicColoringBook.py test.bin --raw --ratio=1:1`\r\n\r\nBut we'll see our tool can do much better!\r\n\r\n***\r\n\r\n## ElectronicColoringBook.py: a real example\r\n\r\n[ElectronicColoringBook.py](https://github.com/doegox/ElectronicColoringBook/blob/master/ElectronicColoringBook.py) is a Python script implementing a number of options we'll discover through the analysis of the [test.bin](./images/test.bin) file we generated above.\r\n\r\nThe main idea is to paint over recurring ECB blocks to reveal more easily, and more nicely, the structure of an ECB-encrypted file. \r\n\r\nIt does so by first computing an histogram of recurring blocks, then paint the most recurring blocks according to a color map. It also tries to guess the right ratio with some stupid hand-made kind of auto-correlation.\r\n\r\nThe color map is the following:\r\n\r\n* The most recurring block is painted in white\r\n* Then the next top ones are painted with some random [saturated](https://en.wikipedia.org/wiki/Colorfulness) color, to make them easy to see\r\n* All remaining blocks will be [painted in black](https://www.youtube.com/watch?v=u6d8eKvegLI), because it's nicer than noise!\r\n\r\nBy default, the tool assumes:\r\n\r\n* a blocksize of 16 bytes, which is the blocksize of AES\r\n* an unknown ratio, to be guessed\r\n* one byte per pixel\r\n* 16 colors will be used: the most widespread block in white, the next 14 randomly, and the others in black.\r\n\r\nLet's see:\r\n\r\n`ElectronicColoringBook.py test.bin`\r\n\r\n<img src=\"./images/test.bin.2.png\" alt=\"test.bin.2\" style=\"width: 400px;\"/>\r\n\r\nAlready better!\r\n\r\nImage is too wide but, given the pixel width, the ratio was correctly recovered and the lines properly wrapped. So we need to adjust the pixel width to compress horizontally the image:\r\n\r\n`ElectronicColoringBook.py test.bin --pixelwidth=3`\r\n\r\n<img src=\"./images/test.bin.3.png\" alt=\"test.bin.3\" style=\"width: 400px;\"/>\r\n\r\nRemember intermediate colors are picked-up randomly so at each attempt it changes.\r\n\r\nNow that the ratio and pixel width are correct we can observe vertical stripes. That happens when you can't have an exact number of pixels in each block and that's exactly the case here: we guessed each pixel requires 3 bytes and the blocksize is 16 so if pixels of the same color are side by side we get e.g. assuming pixels of color `#AABBCC` three types of block content, each of them encrypted to some gibberish:\r\n\r\n```\r\nAABBCCAABBCCAABBCCAABBCCAABBCCAA -> 81E49040C91E64A8F2EB52EB313EADF4\r\nBBCCAABBCCAABBCCAABBCCAABBCCAABB -> 769B3981E49040C9164A83B6CBFB12BF\r\nCCAABBCCAABBCCAABBCCAABBCCAABBCC -> 12B4502017A19C0EB313EADF47638FB2\r\nAABBCCAABBCCAABBCCAABBCCAABBCCAA -> 81E49040C91E64A8F2EB52EB313EADF4\r\nBBCCAABBCCAABBCCAABBCCAABBCCAABB -> 769B3981E49040C9164A83B6CBFB12BF\r\netc\r\n```\r\n\r\nThe histogram given by our tool shows it clearly too:\r\n```\r\ne64572b589bb19c0eb313eadf4769b39       7528 #FF -> #FF #FF #FF\r\n5302017a4208b19834ebbd6ad542e19f       7497 #53 -> #33 #CC #28\r\n81e49040c91e64a83b46cbfb12bf12b4       7459 #9C -> #28 #60 #CC\r\n21da534df36b7bb28134036d4a1e0b22       1100 #B1 -> #42 #28 #CC\r\nf9d6713a5627d4b5d95416de941d6db8       1083 #99 -> #28 #6B #CC\r\na115eadf3b51b5c245dd4757fcf7c4d5       1014 #E3 -> #CC #28 #94\r\n091dd89d9e3e07423c5ddcb2dfe0c912        577 #CB -> #A6 #28 #CC\r\n851fecda89bdd3a133692d4c0f96a8a5        565 #D8 -> #CC #28 #BF\r\n3f84477b3885b86cf2eb52dc0c762ea7        541 #02 -> #CC #2C #28\r\nb0c826f278b5d27e7cc94373b457df44        226 #80 -> #28 #CC #CC\r\n348b13815efe11c8b1ac83e86fd26d4f        225 #58 -> #28 #CC #31\r\ne616ed83f167a272d3ceb5a3259f1114        205 #83 -> #28 #C0 #CC\r\n184f88d431b6072f991a817d26ee8d2e        116 #7A -> #28 #CC #B4\r\nb52adc1063add22fe924ef3b1f6455f7        109 #FE -> #CC #28 #2C\r\n960cf60f2004894d29bb5bfeb1a743ae        100 #0D -> #CC #57 #28\r\n********************************      17617 #00 -> #00 #00 #00\r\n```\r\nSee the number of occurrences? (2nd column) We can group them by three: 7528,7497,7459 ; 1100,1083,1014 ; etc.\r\n\r\nSo let's do it:\r\n\r\n`ElectronicColoringBook.py test.bin -p 3 --groups=3`\r\n\r\n<img src=\"./images/test.bin.4.png\" alt=\"test.bin.4\" style=\"width: 400px;\"/>\r\n\r\nStill one more thing: Pluto's tail is wrapped, that's because before the real data there is the image header (here a PPM header) and in some case a salt if e.g. using openssl with a password.\r\nSo we can apply a small offset to skip them. As we're working with blocks it can't be perfect. Here best is to skip one block, so 16 bytes:\r\n\r\n`ElectronicColoringBook.py test.bin -p 3 -g 3 --offset=1`\r\n\r\n<img src=\"./images/test.bin.5.png\" alt=\"test.bin.5\" style=\"width: 400px;\"/>\r\n\r\nYou can even go as far as telling which colors to use:\r\n\r\n`ElectronicColoringBook.py test.bin -p 3 -g 3 -o 1 -P '#ffffff#fcb604#000000#f9fa00#fccdcc#fc1b23#a61604#a61604#fc8591#97fe37#000000'\r\n\r\n<img src=\"./images/test.bin.9.png\" alt=\"test.bin.9\" style=\"width: 400px;\"/>\r\n\r\nAnd _voil√†!_\r\n\r\nNow you understand better the name of our tool, Electronic Coloring Book :-)\r\n\r\n***\r\n\r\n## ElectronicColoringBook.py: the options\r\n\r\nWe've seen a few options of [ElectronicColoringBook.py](https://github.com/doegox/ElectronicColoringBook/blob/master/ElectronicColoringBook.py) in the example above but there are more of them:\r\n### --colors\r\n```\r\n  -c COLORS, --colors=COLORS\r\n                        Number of colors to use, default=16\r\n```\r\nMaximum number of colors to use is 256. Minimum is 2. Tune it for the best effect.\r\n### --palette\r\n```\r\n  -P PALETTE, --palette=PALETTE\r\n                        Provide list of colors to be used, as hex byte indexes\r\n                        to a rainbow palette or as RGB palette\r\n```\r\nAs seen in the example. Instead of specifying how many colors you want to use, you can tell which ones you want by providing a string made of `#RRGGBB` values or by providing a hex string where each byte encodes the color index, using the same internal saturated rainbow palette, where 00 is white and FF is black. Last element of the list will be used as color for _all the others_\r\n### --blocksize\r\n```\r\n  -b BLOCKSIZE, --blocksize=BLOCKSIZE\r\n                        Blocksize to consider, in bytes, default=16\r\n```\r\nAES blocksize is 16, DES blocksize is 8, but e.g. I've also used the tool against lists of SHA-1 (20 bytes). If you doubt about which blocksize to use, try small values then larger ones to merge repreating vertical stripes. But don't forget to play also with groups other wise you'll lose in resolution.\r\n\r\n`ElectronicColoringBook.py test.bin --blocksize=3 -p 3 -o 10`\r\n\r\n<img src=\"./images/test.bin.6.png\" alt=\"test.bin.6\" style=\"width: 400px;\"/>\r\n\r\n`ElectronicColoringBook.py test.bin --blocksize=48 -p 3 -o 1`\r\n\r\n<img src=\"./images/test.bin.7.png\" alt=\"test.bin.7\" style=\"width: 400px;\"/>\r\n### --groups\r\n```\r\n  -g GROUPS, --groups=GROUPS\r\n                        Groups of N blocks e.g. when blocksize is not multiple\r\n                        of underlying data, default=1\r\n```\r\nAs seen in the example\r\n### --ratio\r\n```\r\n  -r RATIO, --ratio=RATIO\r\n                        Ratio of output image\r\n```\r\nIf you know it or want to tune it, feel free. Example: `-r 4:3`\r\n### --width\r\n```\r\n  -x WIDTH, --width=WIDTH\r\n                        Width of output image\r\n```\r\nIf you know it or want to tune it, feel free.\r\n### --height\r\n```\r\n  -y HEIGHT, --height=HEIGHT\r\n                        Height of output image\r\n```\r\nIf you know it or want to tune it, feel free.\r\n\r\nRatio, width and height are mutually exclusive as one is enough to force the final ratio given the file size.\r\n### --sampling\r\n```\r\n  -s SAMPLING, --sampling=SAMPLING\r\n                        Sampling when guessing image size. Smaller is slower\r\n                        but more precise, default=1000\r\n```\r\nSampling is used for the auto-correlation used while guessing the ratio. I never had to lower it but if you have difficulties recovering the ratio you may try lower sampling values. On the contrary, for large images, you may increase it for faster guess of the ratio.\r\n### --maxratio\r\n```\r\n  -m MAXRATIO, --maxratio=MAXRATIO\r\n                        Max ratio to test when guessing image size. E.g.\r\n                        default=3 means testing ratios from 1:3 to 3:1\r\n```\r\nIf you expect weird ratio you can play with maxratio...\r\nBut remember adjusting pixelwidth will bring you closer to correct ratio too.\r\n### --offset\r\n```\r\n  -o OFFSET, --offset=OFFSET\r\n                        Offset to skip original header, in number of blocks\r\n```\r\nAs seen in the example\r\n### --flip\r\n```\r\n  -f, --flip            Flip image top<>bottom\r\n```\r\nIf you reveal a BMP, you'll have to flip it.\r\n### --pixelwidth\r\n```\r\n  -p PIXELWIDTH, --pixelwidth=PIXELWIDTH\r\n                        How many bytes per pixel in the original image\r\n```\r\nAs seen in the example\r\n### --raw\r\n```\r\n  -R, --raw             Display raw image in 256 colors\r\n```\r\nNo histogram here, no block, each byte is one pixel, using a smooth saturated rainbow palette.\r\n\r\nThis is what we used to display test.bin _raw_ at first, but if we let it guessing the ratio, it gives the kind of typical ECB-encrypted images you've seen before:\r\n\r\n`ElectronicColoringBook.py test.bin --raw`\r\n\r\n<img src=\"./images/test.bin.8.png\" alt=\"test.bin.8\" style=\"width: 400px;\"/>\r\n\r\n### --save\r\n```\r\n  -S, --save            Save a copy of the produced image\r\n```\r\nBy default the tool doesn't save produced images, but you can ask for it.\r\n### --output\r\n```\r\n  -O OUTPUT, --output=OUTPUT\r\n                        Change default output location prefix, e.g. -O\r\n                        /tmp/mytest. Implies -S\r\n```\r\nDefault storage location is to reuse input file location and name, and appending some parameters to its name, e.g.: /mypath/test.bin.b16_p3_c16_g3_x1600_y3200.png\r\n\r\nYou can change storage location, e.g. `-O /tmp/mytest` will generate /tmp/mytest.b16_p3_c16_g3_x1600_y3200.png\r\n\r\n### --dontshow\r\n```\r\n  -D, --dontshow        Don't display image\r\n```\r\nUseful for batching process or if you're not running under X\r\n\r\n***\r\n\r\n## Back to that CTF challenge\r\n\r\nThe original file was [crypted.bmp](./images/crypted.bmp).\r\n\r\nIt's pretty large and a largely uniform background as 225062 of the 270000 ECB blocks are identical, so it's relatively easy to revert it even manually.\r\n\r\nE.g. if someone tries to display the raw content with a classical ratio of 4:3 he'll get something similar to (but with even less clear colors as he won't get them saturated):\r\n\r\n`ElectronicColoringBook.py crypted.bmp --raw --ratio=4:3`\r\n\r\n<img src=\"./images/crypted.bmp.1.png\" alt=\"crypted.bmp.1\" style=\"width: 400px;\"/>\r\n\r\nAnd here is what you get with ElectronicColoringBook.py and the right options:\r\n\r\n`ElectronicColoringBook.py crypted.bmp -c 3 -f -p 4`\r\n\r\n<img src=\"./images/crypted.bmp.2.png\" alt=\"crypted.bmp.2\" style=\"width: 400px;\"/>\r\n\r\n***\r\n\r\n## Wrong ratio?\r\n\r\nIn rare cases, ratio is almost guessed but not entirely correct. This happens e.g. when width is not an entire multiple of blocksize.\r\nHere is a BMP encrypted: [test2.bin](./images/test2.bin)\r\n\r\n`ElectronicColoringBook.py test2.bin -m 4 --raw`\r\n\r\n<img src=\"./images/test2.bin.1.png\" alt=\"test2.bin.1\" style=\"width: 400px;\"/>\r\n \r\n`ElectronicColoringBook.py test2.bin -p 4 -f`\r\n\r\n<img src=\"./images/test2.bin.2.png\" alt=\"test2.bin.2\" style=\"width: 400px;\"/>\r\n \r\nRatio is almost correct. Tool tells us the dimensions are 1500x391\r\nLet's tune them slightly:\r\n\r\n`ElectronicColoringBook.py test2.bin -p 4 -f -x 1501 -o 5`\r\n\r\n<img src=\"./images/test2.bin.3.png\" alt=\"test2.bin.3\" style=\"width: 400px;\"/>\r\n\r\nAnd indeed 1501 is not a multiple of 16.\r\n\r\nDefining our colors:\r\n\r\n`ElectronicColoringBook.py test2.bin -p 4 -f -x 1501 -o 5 -P \"#ffffff#000000#f54700#fb8b00#d40000#ffffff\"`\r\n\r\n<img src=\"./images/test2.bin.4.png\" alt=\"test2.bin.4\" style=\"width: 400px;\"/>\r\n\r\n\r\n***\r\n\r\n## Not only ECB: XOR\r\n\r\nActually the tool can be useful in some other cases, e.g. for XORed files.\r\nLet's take our original example, this time XORed with a key of 5 chars instead of AES-encrypted: \r\n[test3.bin](./images/test3.bin)\r\n\r\n`ElectronicColoringBook.py test3.bin --raw`\r\n\r\n<img src=\"./images/test3.bin.1.png\" alt=\"test3.bin.1\" style=\"width: 400px;\"/>\r\n\r\nBlocksize=5 as XOR key is 5-byte long, pixelwidth is 3 bytes so we'll have to group them by 3 as 3 and 5 are coprimes, and finally a little offset to get rid of the header:\r\n\r\n`ElectronicColoringBook.py test3.bin -b 5 -g 3 -p 3 -o 3`\r\n\r\n<img src=\"./images/test3.bin.2.png\" alt=\"test3.bin.2\" style=\"width: 400px;\"/>\r\n\r\nAnd if we apply the same palette manually as we did on the ECB file:\r\n\r\n`ElectronicColoringBook.py test3.bin -b 5 -g 3 -p 3 -o 3 -P '#ffffff#fcb604#000000#f9fa00#fccdcc#fc1b23#a61604#a61604#fc8591#97fe37#000000'`\r\n\r\n<img src=\"./images/test3.bin.3.png\" alt=\"test3.bin.3\" style=\"width: 400px;\"/>\r\n\r\n***\r\n\r\n## Not only ECB: anything\r\n\r\nActually we can use the tool to colorize whatever we want and reveal some structures.\r\nE.g. applied on /bin/ls on an amd64 arch, this gives:\r\n\r\n```\r\nElectronicColoringBook.py /bin/ls -b1 -m2\r\n00      28929 #FF -> #FF #FF #FF\r\nff       5648 #1F -> #CC #9C #28\r\n48       3727 #EB -> #CC #28 #75\r\n20       3566 #C7 -> #97 #28 #CC\r\n89       2258 #04 -> #CC #34 #28\r\n0f       2127 #D3 -> #C5 #28 #CC\r\n41       1847 #F3 -> #CC #28 #57\r\n8b       1560 #AD -> #33 #28 #CC\r\n24       1356 #05 -> #CC #38 #28\r\n40       1288 #F6 -> #CC #28 #4B\r\n44       1261 #CB -> #A6 #28 #CC\r\n83       1224 #9B -> #28 #63 #CC\r\n74       1223 #B5 -> #51 #28 #CC\r\n01       1208 #6A -> #28 #CC #77\r\n4c       1187 #C7 -> #97 #28 #CC\r\n**      51583 #00 -> #00 #00 #00\r\nTrying to guess ratio between 1:2 and 2:1 ...\r\nWidth: from 165 to 662\r\nSampling: 1000\r\nProgress: 200 300 400 500 600 \r\nSize:  (384, 286)\r\n```\r\nWe get a byte histogram, and a graphical representation:\r\n\r\n<img src=\"./images/test4.bin.1.png\" alt=\"test4.bin.1\" style=\"width: 400px;\"/>\r\n\r\nWhile applied on /bin/ls on an ARM arch, we can use a blocksize of 4:\r\n\r\n```\r\nElectronicColoringBook.py /bin/ls -b4 -m2\r\n00000000        681 #00 -> #FF #FF #FF\r\n20202020        428 #A9 -> #28 #2D #CC\r\n1eff2fe1        358 #8F -> #28 #92 #CC\r\n000050e3        221 #D8 -> #CC #28 #BF\r\n58ab0000        217 #59 -> #28 #CC #35\r\n000053e3        201 #E4 -> #CC #28 #90\r\n0400a0e1        120 #42 -> #74 #CC #28\r\n2c990000        113 #D5 -> #CC #28 #CA\r\n00c68fe2        112 #C7 -> #97 #28 #CC\r\n12000000        112 #26 -> #CC #B7 #28\r\n1dca8ce2        112 #8C -> #28 #9D #CC\r\nf8c90000        100 #2E -> #C1 #CC #28\r\n0000a0e3         98 #0B -> #CC #4F #28\r\n0030a0e3         98 #82 -> #28 #C4 #CC\r\n0700a0e1         81 #2C -> #C9 #CC #28\r\n********      21037 #FF -> #00 #00 #00\r\nTrying to guess ratio between 1:2 and 2:1 ...\r\nWidth: from 155 to 620\r\nSampling: 1000\r\nProgress: 200 300 400 500 600 \r\nSize:  (240, 401)\r\n```\r\n\r\nThis gives a nice overview of the top most used ARM instructions as we can recognize in the histogram:\r\n```\r\n   e12fff1e \tbx\tlr\r\n   e3500000 \tcmp\tr0, #0\r\n   0000ab58 \tmany pointers to loc_AB58 in big jump table?\r\n   e3530000 \tcmp\tr3, #0\r\n   e1a00004 \tmov\tr0, r4\r\n   etc\r\n```\r\n<img src=\"./images/test5.bin.1.png\" alt=\"test5.bin.1\" style=\"width: 400px;\"/>\r\n\r\n***\r\n\r\n## FAQ\r\n\r\n### Why not using Lena image as everybody else?\r\n\r\nYeah I would have preferred [Lena](https://en.wikipedia.org/wiki/Lenna) too, but come on, it's coloring book, not Playboy!\r\n\r\nMore seriously, ElectronicColoringBook works only on large areas of (strictly) uniform color, which is rarely the case in photography (no, that pink wasn't uniform enough).\r\n\r\nAnd to make it clear, it won't work on jpeg, png or other compressed or vectorized formats either.\r\n\r\n### Oh come on, pleeeeeze!\r\n\r\nOk ok, here is an AES-ECB encrypted BMP (ARGB) of a vectorized version reduced to 20 colors: [test7.bin](./images/test7.bin).\r\n\r\nIt will be the occasion to show how to choose colors...\r\n\r\nSo BMP => -f; ARGB => -p 4; 20 colors => -c 21 (we want black for the \"noise\")\r\n\r\n`ElectronicColoringBook.py test7.bin -p 4 -f -o 4 -c 21 -r 1:1`\r\n\r\n<img src=\"./images/test7.bin.1.png\" alt=\"test7.bin.1\" style=\"width: 400px;\"/>\r\n\r\nWe know the white spot is the largest so we can paint it.\r\nNow let's identify the next area:\r\n\r\n`ElectronicColoringBook.py test7.bin -p 4 -f -o 4 -r 1:1 -P '#d35e5d#ffffff#000000'`\r\n\r\n<img src=\"./images/test7.bin.2.png\" alt=\"test7.bin.2\" style=\"width: 400px;\"/>\r\n\r\n`ElectronicColoringBook.py test7.bin -p 4 -f -o 4 -r 1:1 -P '#d35e5d#c97e76#ffffff#000000'`\r\n\r\n<img src=\"./images/test7.bin.3.png\" alt=\"test7.bin.3\" style=\"width: 400px;\"/>\r\n\r\netc, till:\r\n\r\n`ElectronicColoringBook.py test7.bin -p 4 -f -o 4 -r 1:1 -P '#d35e5d#c97e76#5f1945#ac414d#e07e68#671a3e#cf6c70#e5bcac#ea9173#d7a79f#be5258#f0c28f#69285a#802e4a#943147#d8988f#de8a7d#915884#994b58#b38f94#333333'`\r\n\r\n<img src=\"./images/test7.bin.4.png\" alt=\"test7.bin.4\" style=\"width: 400px;\"/>\r\n\r\n\r\n### What about the original ECB mascot?\r\n\r\nThe problem is that I can't find the original encrypted version of Tux used to generate the ECB-encrypted mascot you can find everywhere else, neither the original non-encrypted version.\r\n\r\n![ecb tux](./images/Tux_ecb.jpg)\r\n\r\nis a jpeg, scaled down version so it's impossible to work from that one.\r\n\r\nSorry. See also below, the efforts of Filippo to contact the original author.\r\n\r\n***\r\n\r\n## Related (art)work\r\n\r\n### Filippo & The ECB Penguin\r\n\r\nFilippo (probably better known for his [Heartbleed test](https://filippo.io/Heartbleed/)) wrote a post about [the ECB Penguin](https://filippo.io/the-ecb-penguin/) with the goal to make better-looking versions.\r\n\r\nThe trick was to work from a very large image (about 2500 x 3000) so the relative loss of precision due to the blocksize decreases significantly and if you look to the picture scaled down, the local noise tends to be smoothed away.\r\n\r\nBut if look at the image closer you'll see the usual random colors due to ECB and on the scaled down version, colors tend to be averaged to some grayish faded colors.\r\n\r\n<img src=\"./images/test6.bin.png\" alt=\"test6.bin\" style=\"width: 400px;\"/>\r\n\r\n### GynCryption\r\n\r\n[GynCryption](https://corkami.googlecode.com/svn/trunk/src/angecryption/GynCryption/) is a variant of AngeCryption suggested by Gynvael Coldwind, using ECB and brute-forcing a key such that the encrypted file header becomes a valid header pointing to another part of the file.\r\n\r\nSo there the resulting image is radically different.\r\n\r\n<img src=\"./images/gyncryption.png\" alt=\"gyncryption\" style=\"width: 400px;\"/>\r\n\r\nQuite funny trick!\r\n\r\nCheck [Ange's presentations](https://code.google.com/p/corkami/) if you don't know Angecryption yet.\r\n\r\n***\r\n\r\n## About the author\r\nThis tool has been written by [Philippe Teuwen](http://wiki.yobi.be/wiki/User:PhilippeTeuwen).\r\n\r\nDon't hesitate to contact me for any suggestion, remark or alternative usages.\r\n\r\nYou can also use the [issue tracker](https://github.com/doegox/ElectronicColoringBook/issues) or just [fork](https://github.com/doegox/ElectronicColoringBook/fork) and propose pull requests on Github.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}