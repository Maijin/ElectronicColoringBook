<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>ElectronicColoringBook by doegox</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>ElectronicColoringBook</h1>
        <h2>Colorize data file according to repetitive chunks, typical in ECB encrypted</h2>

        <section id="downloads">
          <a href="https://github.com/doegox/ElectronicColoringBook/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/doegox/ElectronicColoringBook/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/doegox/ElectronicColoringBook" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a name="welcome-to-the-electronic-coloring-book-project-page" class="anchor" href="#welcome-to-the-electronic-coloring-book-project-page"><span class="octicon octicon-link"></span></a>Welcome to the Electronic Coloring Book project page.</h3>

<p>The name is obviously a wordplay with <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29">Electronic Codebook</a>, the simplest but also the most insecure chaining mode of operations to be used with a block cipher.</p>

<p>From Wikipedia:</p>

<blockquote>
<p>The disadvantage of this method is that identical plaintext blocks are encrypted into identical ciphertext blocks; thus, it does not hide data patterns well. In some senses, it doesn't provide serious message confidentiality, and it is not recommended for use in cryptographic protocols at all.
A striking example of the degree to which ECB can leave plaintext data patterns in the ciphertext can be seen when ECB mode is used to encrypt a bitmap image which uses large areas of uniform color. While the color of each individual pixel is encrypted, the overall image may still be discerned as the pattern of identically colored pixels in the original remains in the encrypted version.</p>
</blockquote>

<p>This is typically illustrated with our favorite mascot:</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f0/Tux_ecb.jpg" alt="ecb tux"></p>

<p>Yes we can see it despite it's encrypted, but it's neither that obvious nor visually satisfying, for several reasons we'll explain. We can do better! And that's the goal of this little project.</p>

<h3>
<a name="why-ecb-forensics-isnt-that-easy" class="anchor" href="#why-ecb-forensics-isnt-that-easy"><span class="octicon octicon-link"></span></a>Why ECB forensics isn't that easy?</h3>

<p>Those ECB exemplary images are made artificially: the author knows the original file format (width, height, pixel encoding) and typically overwrites the encrypted header with the original one.</p>

<p>But when a file is encrypted and you don't know anything about it, it's not that simple.
<br>One example is the 300 points challenge of the <em>2014 Nuit du Hack CTF Quals</em> called <em>The Another One</em>. All you get is an encrypted BMP (as you can guess from the file extension). More details on the resolution of that challenge are available <a href="http://wiki.yobi.be/wiki/NDH_Writeups#Another_One">here</a>.</p>

<p>It appears quickly that there are recurring encrypted blocks but practical problems are to recover the unknown parameters:</p>

<ul>
<li>width and height of the image</li>
<li>pixel encoding. Here it's a BMP but BMP can <a href="https://en.wikipedia.org/wiki/BMP_file_format#Pixel_format">encode each pixel</a> in 1 bit, 2 bits, 4 bits, 8 bits, 16 bits, 24 bits or 32 bits so that doesn't really help.</li>
<li>layout. Here it's a BMP so starting from bottom left to top right, line by line.</li>
</ul><p>Pixel encoding, width and height link back to the total encrypted file size:</p>

<p><em>header + width * height * bytes_per_pixel + padding = filesize</em></p>

<p>Here is another example we'll walk through. For the record the binary blob was created from some ppm (as we need a non-compressed bitmap to start with) as:</p>

<p><code>openssl enc -e -aes-128-ecb -in test.ppm -out test.bin -k toto</code></p>

<p>test.bin is available <a href="./images/test.bin">here</a></p>

<p>At first we'll use a square ratio and color each byte.</p>

<p><img src="./images/test.bin.1.png" alt="test.bin.1"></p>

<p>Nothing really recognizable, isn't it?</p>

<p>For the record, this image was produced with our tool, asking for a raw rendering and square ratio:</p>

<p><code>ecb-colorize.py test.bin --raw --ratio=1:1</code></p>

<p>But we'll see our tool can do much better!</p>

<h3>
<a name="electroniccoloringbookpy-a-real-example" class="anchor" href="#electroniccoloringbookpy-a-real-example"><span class="octicon octicon-link"></span></a>ElectronicColoringBook.py: a real example</h3>

<p>ElectronicColoringBook.py is a Python (doh!) script implementing a number of options we'll discover throught the analysis of the <a href="./images/test.bin">test.bin</a> file we generated.</p>

<p>Its goal is to paint over recurring ECB blocks to reveal more easily, and more nicely, the structure of an ECB-encrypted file. It does so by first computing an histogram of recurring blocks, then map it to a color map. It also tries to guess the right ratio with some fast stupid auto-correlation.</p>

<p>By default, it assumes:</p>

<ul>
<li>a blocksize of 16 bytes, which is the blocksize of AES</li>
<li>an unknown ratio, to be guessed</li>
<li>one byte per pixel</li>
<li>16 colors will be used: the most widespread block in white, the next 14 randomly, and all remaining blocks will be <a href="https://www.youtube.com/watch?v=u6d8eKvegLI">painted in black</a>
</li>
</ul><p>Let's see:</p>

<p><code>ElectronicColoringBook.py test.bin</code></p>

<p><img src="./images/test.bin.2.png" alt="test.bin.2"></p>

<p>Already better!</p>

<p>Image is too wide but, given the pixel width, the ratio was correctly recovered and the lines properly wrapped. So we need to adjust the pixel width to compress horizontally the image:</p>

<p><code>ElectronicColoringBook.py test.bin --pixelwidth=3</code></p>

<p><img src="./images/test.bin.3.png" alt="test.bin.3"></p>

<p>Remember intermediate colors are picked-up randomly so at each attempt it changes.</p>

<p>Now that the ratio and pixel width are correct we can observe vertical stripes. That happens when you can't have an exact number of pixels in each block and that's exactly the case here: we guessed each pixel requires 3 bytes and the blocksize is 16 so if pixels of the same color are side by side we get e.g. assuming pixels of color <code>#AABBCC</code> three types of block content, each of them encrypted to some gibberish:</p>

<pre><code>AABBCCAABBCCAABBCCAABBCCAABBCCAA -&gt; 81E49040C91E64A8F2EB52EB313EADF4
BBCCAABBCCAABBCCAABBCCAABBCCAABB -&gt; 769B3981E49040C9164A83B6CBFB12BF
CCAABBCCAABBCCAABBCCAABBCCAABBCC -&gt; 12B4502017A19C0EB313EADF47638FB2
AABBCCAABBCCAABBCCAABBCCAABBCCAA -&gt; 81E49040C91E64A8F2EB52EB313EADF4
BBCCAABBCCAABBCCAABBCCAABBCCAABB -&gt; 769B3981E49040C9164A83B6CBFB12BF
etc
</code></pre>

<p>The histogram given by our tool shows it clearly too:</p>

<pre><code>e64572b589bb19c0eb313eadf4769b39       7528 #FF -&gt; #FF #FF #FF
5302017a4208b19834ebbd6ad542e19f       7497 #53 -&gt; #33 #CC #28
81e49040c91e64a83b46cbfb12bf12b4       7459 #9C -&gt; #28 #60 #CC
21da534df36b7bb28134036d4a1e0b22       1100 #B1 -&gt; #42 #28 #CC
f9d6713a5627d4b5d95416de941d6db8       1083 #99 -&gt; #28 #6B #CC
a115eadf3b51b5c245dd4757fcf7c4d5       1014 #E3 -&gt; #CC #28 #94
091dd89d9e3e07423c5ddcb2dfe0c912        577 #CB -&gt; #A6 #28 #CC
851fecda89bdd3a133692d4c0f96a8a5        565 #D8 -&gt; #CC #28 #BF
3f84477b3885b86cf2eb52dc0c762ea7        541 #02 -&gt; #CC #2C #28
b0c826f278b5d27e7cc94373b457df44        226 #80 -&gt; #28 #CC #CC
348b13815efe11c8b1ac83e86fd26d4f        225 #58 -&gt; #28 #CC #31
e616ed83f167a272d3ceb5a3259f1114        205 #83 -&gt; #28 #C0 #CC
184f88d431b6072f991a817d26ee8d2e        116 #7A -&gt; #28 #CC #B4
b52adc1063add22fe924ef3b1f6455f7        109 #FE -&gt; #CC #28 #2C
960cf60f2004894d29bb5bfeb1a743ae        100 #0D -&gt; #CC #57 #28
********************************      17617 #00 -&gt; #00 #00 #00
</code></pre>

<p>See the number of occurrences? (2nd column) We can group them by three: 7528,7497,7459 ; 1100,1083,1014 ; etc.</p>

<p>So let's do it:</p>

<p><code>ElectronicColoringBook.py test.bin -p 3 --group=3</code></p>

<p><img src="./images/test.bin.4.png" alt="test.bin.4"></p>

<p>Still one more thing: Pluto's tail is wrapped, that's because before the real data there is the image header (here a PPM header) and in this case a salt because of the way we used openssl.
So we can apply a small offset to skip them. As we're working with blocks it can't be perfect. Here best is to skip two blocks, so 32 bytes:</p>

<p><code>ElectronicColoringBook.py test.bin -p 3 -g 3 --offset=2</code></p>

<p><img src="./images/test.bin.5.png" alt="test.bin.5"></p>

<p>And <em>voil√†!</em></p>

<p>Now you understand better the name of our tool, Electronic Coloring Book :-)</p>

<h3>
<a name="electroniccoloringbookpy-the-options" class="anchor" href="#electroniccoloringbookpy-the-options"><span class="octicon octicon-link"></span></a>ElectronicColoringBook.py: the options</h3>

<p>We've seen a few options in the example above but there are more of them:</p>

<pre><code>  -c COLORS, --colors=COLORS
                        Number of colors to use, default=16
</code></pre>

<p>Maximum number of colors to use is 256. Minimum is 2. Tune it for the best effect.</p>

<pre><code>  -b BLOCKSIZE, --blocksize=BLOCKSIZE
                        Blocksize to consider, in bytes, default=16
</code></pre>

<p>AES blocksize is 16, DES blocksize is 8, but e.g. I've also used the tool against lists of SHA-1 (20 bytes). If you doubt about which blocksize to use, try small values then larger ones to merge repreating vertical stripes. But don't forget to play also with groups other wise you'll lose in resolution.</p>

<p><code>ElectronicColoringBook.py test.bin --blocksize=3 -p 3 -o 10</code></p>

<p><img src="./images/test.bin.6.png" alt="test.bin.6"></p>

<p><code>ElectronicColoringBook.py test.bin --blocksize=48 -p 3 -o 1</code></p>

<p><img src="./images/test.bin.7.png" alt="test.bin.7"></p>

<pre><code>  -g GROUPS, --groups=GROUPS
                        Groups of N blocks e.g. when blocksize is not multiple
                        of underlying data, default=1
</code></pre>

<p>As seen in the example</p>

<pre><code>  -r RATIO, --ratio=RATIO
                        Ratio of output image
</code></pre>

<p>If you know it or want to tune it, feel free. Example: <code>-r 4:3</code></p>

<pre><code>  -x WIDTH, --width=WIDTH
                        Width of output image
</code></pre>

<p>If you know it or want to tune it, feel free.</p>

<pre><code>  -y HEIGHT, --height=HEIGHT
                        Height of output image
</code></pre>

<p>If you know it or want to tune it, feel free.</p>

<p>Ratio, width and height are mutually exclusive as one is enough to force the final ratio given the file size.</p>

<pre><code>  -s SAMPLING, --sampling=SAMPLING
                        Sampling when guessing image size. Smaller is slower
                        but more precise, default=1000
</code></pre>

<p>Sampling is used for the auto-correlation used while guessing the ratio. I never had to lower it but if you have difficulties recovering the ratio you may try lower sampling values.</p>

<pre><code>  -m MAXRATIO, --maxratio=MAXRATIO
                        Max ratio to test when guessing image size. E.g.
                        default=3 means testing ratios from 1:3 to 3:1
</code></pre>

<p>If you expect weird ratio you can play with maxratio...
But remember adjusting pixelwidth will bring you closer to correct ratio too.</p>

<pre><code>  -o OFFSET, --offset=OFFSET
                        Offset to skip original header, in number of blocks
</code></pre>

<p>As seen in the example</p>

<pre><code>  -f, --flip            Flip image top&lt;&gt;bottom
</code></pre>

<p>If you reveal a BMP, you'll have to flip it.</p>

<pre><code>  -p PIXELWIDTH, --pixelwidth=PIXELWIDTH
                        How many bytes per pixel in the original image
</code></pre>

<p>As seen in the example</p>

<pre><code>  -R, --raw             Display raw image in 256 colors
</code></pre>

<p>No histogram here, no block, each byte is one pixel, using a smooth rainbow palette.</p>

<p>This is what we used to display test.bin <em>raw</em> at first</p>

<h3>
<a name="wrong-ratio" class="anchor" href="#wrong-ratio"><span class="octicon octicon-link"></span></a>Wrong ratio?</h3>

<p>In rare cases, ratio is almost guessed but not entirely correct. This happens e.g. when width is not an entire multiple of blocksize.
Here is a BMP encrypted: <a href="./images/test2.bin">test2.bin</a></p>

<p><code>ElectronicColoringBook.py test2.bin -m 4 --raw</code></p>

<p><img src="./images/test2.bin.1.png" alt="test2.bin.1"></p>

<p><code>ElectronicColoringBook.py test2.bin -p 4 -f</code></p>

<p><img src="./images/test2.bin.2.png" alt="test2.bin.2"></p>

<p>Ratio is almost correct. Tool tells us the dimensions are 1500x391
Let's tune them slightly:</p>

<p><code>ElectronicColoringBook.py test2.bin -p 4 -f -x 1501 -o 5</code></p>

<p><img src="./images/test2.bin.3.png" alt="test2.bin.3"></p>

<p>And indeed 1501 is not a multiple of 16.</p>

<h3>
<a name="not-only-ecb-xor" class="anchor" href="#not-only-ecb-xor"><span class="octicon octicon-link"></span></a>Not only ECB: XOR</h3>

<p>Actually the tool can be useful in some other cases, e.g. for XORed files.
Let's take our original example, this time XORed with a key of 5 chars instead of AES-encrypted: 
<a href="./images/test3.bin">test3.bin</a></p>

<p><code>ElectronicColoringBook.py test3.bin --raw</code></p>

<p><img src="./images/test3.bin.1.png" alt="test3.bin.1"></p>

<p>Blocksize=5 as XOR key is 5-byte long, pixelwidth is 3 bytes so we'll have to group them by 3 as 3 and 5 are coprimes, and finally a little offset to get rid of the header:</p>

<p>`ElectronicColoringBook.py test3.bin -b 5 -g 3 -p 3 -o 3</p>

<p><img src="./images/test3.bin.2.png" alt="test3.bin.2"></p>
      </section>
    </div>

    
  </body>
</html>